% -*- compile-command: "stack exec -- pdflatex --enable-write18 fenwick.tex" -*-

%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[acmsmall]{acmart}\settopmatter{}


%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{ICFP} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2020}
\acmMonth{9}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format must update the '\documentclass' and
%% topmatter commands above; see 'acmart-sigplanproc-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\usepackage{booktabs}   %% For formal tables: http://ctan.org/pkg/booktabs
\usepackage{todonotes}
\usepackage{enumitem}
\newcommand{\todoi}[2][]{\todo[inline, #1]{#2}}
\usepackage[backend=pgf, input, extension=pgf, outputdir=diagrams]{diagrams-latex}

\usepackage{xspace}
\usepackage{prettyref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Prettyref

\newrefformat{fig}{Figure~\ref{#1}}
\newrefformat{sec}{section~\ref{#1}}
\newrefformat{eq}{equation~\eqref{#1}}
\newrefformat{prob}{Problem~\ref{#1}}
\newrefformat{tab}{Table~\ref{#1}}
\newrefformat{thm}{Theorem~\ref{#1}}
\newrefformat{lem}{Lemma~\ref{#1}}
\newrefformat{claim}{Claim~\ref{#1}}
\newrefformat{obs}{Observation~\ref{#1}}
\newrefformat{prop}{Proposition~\ref{#1}}
\newrefformat{defn}{Definition~\ref{#1}}
\newrefformat{cor}{Corollary~\ref{#1}}
\providecommand{\pref}{}
\renewcommand{\pref}[1]{\prettyref{#1}}

% \Pref is just like \pref but it uppercases the first letter; for use
% at the beginning of a sentence.
\providecommand{\Pref}{}
\renewcommand{\Pref}[1]{%
  \expandafter\ifx\csname r@#1\endcsname\relax {\scriptsize[ref]}
    \else
    \edef\reftext{\prettyref{#1}}\expandafter\MakeUppercase\reftext
    \fi
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\mempty}{\ensuremath{\varepsilon}}

\newcommand{\Up}{\textbf{U}\xspace}
\newcommand{\RQ}{\textbf{RQ}\xspace}

\newcommand{\ie}{\emph{i.e.}\xspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

%% Title information
\title{You Could Have Invented Fenwick Trees (Functional Pearl)}
   %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
% \titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
% \subtitle{Subtitle}                     %% \subtitle is optional
% \subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{Brent A. Yorgey}
% \authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
% \orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  % \position{Position1}
  \department{Department of Mathematics and Computer Science}
  \institution{Hendrix College}            %% \institution is required
  \streetaddress{1600 Washington Ave.}
  \city{Conway}
  \state{AR}
  \postcode{72032}
  \country{USA}                    %% \country is recommended
}
\email{yorgey@hendrix.edu}          %% \email is recommended


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
Text of abstract \ldots.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{keyword1, keyword2, keyword3}  %% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle


\section{Introduction}

Suppose we have a sequence of $n$ integers $a_1, a_2, \dots, a_n$, and
want to be able to perform an arbitrary sequence of two operations:

\begin{itemize}
\item \emph{Update} the value at index $i$ to a new value $v$. We
  abbreviate this operation as \Up.
\item Find the sum of all values in a particular range $[i, j]$,
  that is, $a_i + a_{i+1} + \dots + a_j$.  We call this a \emph{range
    query}, abbreviated \RQ.
\end{itemize}

If we simply store the integers in a mutable array, then we can update
in constant time, but a range query requires up to $O(n)$ time, since
we must iterate through the range $[i, j]$ to add up the values.

In order to improve the running time of a range query, one obvious
idea is to somehow cache (at least some of the) range sums.  However,
this must be done with care, since the cached sums must also be
updated appropriately when updating.  For example, a straightforward
approach would be to use an array $P$ where $P_i$ stores the prefix
sum $a_1 + \dots + a_i$.  Now range queries are fast: we can obtain
$a_i + \dots + a_j$ in constant time by computing $P_j - P_{i-1}$ (for
convenience we set $P_0 = 0$ so this works even when $i=1$).
Unfortunately, it is update that now takes linear time, since changing
$a_i$ requires updating $P_j$ for every $j \geq i$.

Is it possible to get \emph{both} operations to run in sublinear time?
XXX write about arithmetic coding as original motivation: need to
quickly find prefix sums of probabilities.  Read up on this a bit
more.

The answer, known since at least XXX (citation), is yes: we can get
both operations to run in $O(\lg n)$ time if we use a
divide-and-conquer approach to caching range sums.  Just make a binary
tree where the leaves store the sequence itself, and every internal
node stores the sum of its two children.  (This should be a familiar
idea to many functional programmers; for example, finger trees
\citep{Hinze-Paterson:FingerTree} use a similar sort of scheme.)  The
resulting data structure is known as a \emph{segment tree} (XXX
citation?), presumably because each internal node ultimately caches
the sum of a (contiguous) \emph{segment} of the underlying sequence.
For simplicity, we will assume that $n$ is a power of two, although it
is easy to generalize to situations where it is not.
\pref{fig:segment-tree} shows a segment tree built on a random sample
array of length $n=16$. Each leaf of the tree corresponds to an array
entry; each internal node is shown with a grey bar showing the range
of the underlying array of which it is the sum.

\todoi{Note that ``segment tree'' means two different things.  The
  Wikipedia article is about something used in computational geometry
  for representing intervals.  But lots of places on the web,
  specially competitive programming stuff, use it to refer to this
  simpler thing.  See in particular CP3 sec. 2.4.3.}

\begin{figure}
\begin{center}
\begin{diagram}[width=300]
  import FenwickDiagrams
  import SegTree

  dia :: Diagram B
  dia = sampleArray
    # mkSegTree
    # fmap getSum
    # drawSegTree def
\end{diagram}
\end{center}
\caption{A segment tree} \label{fig:segment-tree}
\end{figure}

Let's see how we can use a segment tree to implement the two required
operations to run in $O(\lg n)$ time.

\begin{itemize}
\item To update the value at index $i$, we also need to update any
  cached range sums which include it.  These are exactly the nodes
  along the path from the leaf at index $i$ to the root of the tree;
  there are $O(\lg n)$ such nodes.  \pref{fig:segment-tree-update}
  illustrates this update process for the example segment tree from
  \pref{fig:segment-tree}.

\begin{figure}
\begin{center}
\begin{diagram}[width=300]
  import FenwickDiagrams
  import SegTree
  import Data.Monoid
  import Control.Arrow ((***))

  dia :: Diagram B
  dia = sampleArray
    # map ((,) (Any False))
    # mkSegTree
    # update 5 (Any True, Sum 3)
    # fmap (getAny *** getSum)
    # drawSegTree (mkSTOpts showUpdateOpts)
\end{diagram}
\end{center}
\caption{Updating a segment tree} \label{fig:segment-tree-update}
\end{figure}

\item To perform a range query, we recurse through the tree while
  keeping track of the range covered by the current node.
  \begin{itemize}
  \item If the range of the current node is wholly contained within
    the desired range $[i, j]$, return the value of the current
    node.
  \item If the range of the current node does not overlap with the
    desired range at all, return $0$.
  \item Otherwise, recurse on both children and return the sum of the
    results.
  \end{itemize}
\begin{figure}
\begin{center}
\begin{diagram}[width=300]
  import FenwickDiagrams
  import SegTree
  import Data.Monoid
  import Control.Arrow ((***), second)

  dia :: Diagram B
  dia = vsep 0.7
    [ sampleArray
      # mkSegTree
      # rq' i j
      # fst
      # drawSegTree (mkSTOpts showRangeOpts)
    , (fst (leafX i n) ^& 0) ~~ (snd (leafX j n) ^& 0)
      # lc green
      # applyStyle defRangeStyle
    ]
    where
      i = 4
      j = 11
      n = length sampleArray
\end{diagram}
\end{center}
\caption{Performing a range query on a segment tree} \label{fig:segment-tree-range-query}
\end{figure}
\pref{fig:segment-tree-range-query} illustrates the process of computing
the sum of the range $[4 \dots 11]$.  Blue nodes are the ones we
recurse through; green nodes are those whose range is wholly contained
in the desired range, and are returned without recursing further; grey
nodes are disjoint from the desired range and return zero.

On this small example tree, it may seem that we visit a significant
fraction of the total nodes, but in general, we visit no more than
about $4 \lg n$ nodes.  \pref{fig:big-range-query} makes this more
clear.  Only one blue node in the entire tree can have two blue
children, \todoi{why?} and hence each level of the tree can contain at
most two blue nodes and two non-blue nodes. \todoi{improve this
  explanation!  Something about basically performing a binary search
  to find each endpoint, with leaves to either side (either fully
  included nodes towards the range or zero nodes away from it).}
\begin{figure}
\begin{center}
\begin{diagram}[width=300]
  import FenwickDiagrams
  import SegTree
  import Data.Monoid
  import Control.Arrow ((***), second)

  dia :: Diagram B
  dia = vsep 0.7
    [ sampleArray4
      # mkSegTree
      # rq' i j
      # fst
      # drawSegTree (mkSTOpts (showRangeOpts' False False))
    , (fst (leafX i n) ^& 0) ~~ (snd (leafX j n) ^& 0)
      # lc green
      # applyStyle defRangeStyle
    ]
    where
      i = 12
      j = 42
      n = length sampleArray4
\end{diagram}
\end{center}
\caption{Performing a range query on a larger segment tree} \label{fig:big-range-query}
\end{figure}
\end{itemize}

\section{Segment Trees, Generally}

Although most reference material on segment trees (or Fenwick trees)
talks about sums of \emph{integers}, this is needlessly specific.  In
general, all we need is a sequence of elements $a_1, \dots, a_n$ from
some \emph{monoid}.  Recall that a monoid is a set $M$ together with
an associative binary operation $\oplus$ and an identity element
$\varepsilon \in M$ such that
$m \oplus \mempty = \mempty \oplus m = m$ for all $m \in M$. We will
continue to talk about ``sums'' of elements of a monoid $M$ even
though the monoidal operation need not be sum-like in general (for
example, the set of natural numbers forms a monoid under
multiplication).  Note, however, that the ``sum'' metaphor fails us in
one important way: in general, $\oplus$ need not be commutative, that
is, we may have $a \oplus b \neq b \oplus a$.  All the data structures
we will discuss work perfectly well for non-commutative monoids, but
some care is required to ensure values are properly ordered.

Some monoids also have \emph{inverses}, that is, for each $m \in M$
there is an element $-m \in M$ such that
$m \oplus (-m) = (-m) \oplus m = \mempty$.  Such monoids-with-inverses
are called \emph{groups}.  For convenience, in any group we can also
define a ``subtraction'' operation $a \ominus b = a \oplus (-b)$.
Although basic segment trees work just fine with any monoid, other
related constructions we will consider require a group.

\todoi{Haskell implementation.}
\todoi{requires 2x storage.  Indexing scheme?  Relevant in an array implementation.}

\section{Segment Trees are Redundant}

Of course segment trees are redundant in the sense that they cache
range sums which could easily be recomputed from the original
sequence.  That's the whole point: caching these ``redundant'' sums
allows us to perform arbitrary range queries more quickly. But segment
trees are actually redundant in a stronger sense: it turns out that if
the values come from a group, we can throw out almost \emph{half} of
the data in a segment tree and still retain the $O(\log n)$ running
time for updates and range queries!

How, you ask?  Simple: just throw out the data associated with
\emph{every right child}. \pref{fig:deactivate-right} shows the same
example tree we have been using, but with the data deleted from every
right child.  Note that ``every right child'' includes both leaves and
internal nodes: we throw out the data associated to \emph{any} node
which is the right child of its parent.  We will refer to the nodes
with discarded data as \emph{inactive} and the remaining nodes (that
is, left children and the root) as \emph{active}.  We will also say
that a tree with all its right children inactivated in this way has been
\emph{thinned}.

\begin{figure}
\begin{center}
\begin{diagram}[width=300]
  import FenwickDiagrams
  import SegTree
  import Data.Monoid
  import Control.Arrow ((***), first, second)

  dia :: Diagram B
  dia = sampleArray
    # mkSegTree
    # deactivate
    # drawSegTree (mkSTOpts (showInactiveOpts False))
\end{diagram}
\end{center}
\caption{Inactivating all right children in a segment tree} \label{fig:deactivate-right}
\end{figure}

First, let's see that there is enough information remaining to
reconstruct the information that was discarded.

\begin{theorem}
  The value of any inactive node in a thinned segment tree can be
  recovered, in $O(\lg n)$ time, using only the values of active nodes.
\end{theorem}
\begin{proof}
  The proof is by induction on the depth of an inactive node from its
  nearest active ancestor.  Note that every inactive node must have an
  active ancestor; if nothing else, the root of the tree remains
  active.
  \begin{itemize}
  \item In the base case, if an inactive node is the child of an
    active node, the situation looks like the diagram on the left side
    of \pref{fig:inactive-child}.
    \begin{figure}
    \begin{center}
    \begin{diagram}[width=150]
      import FenwickDiagrams
      import SegTree
      dia :: Diagram B
      dia = hsep 2
        [ t # deactivate # drawSegTree stopts
          # beneath upedge
        , t # deactivateR Inactive # drawSegTree stopts
          # beneath upedge
        ]
        where
          t = Branch "p" 1 2 (Leaf "l" 1) (Leaf "r" 2)
          iopts = (showInactiveOpts True) { nodeShape = const circleNodeShape }
          stopts = (mkSTOpts iopts) { stVSep = 0.5 }
          upedge = ((origin ~~ ((-0.5) ^& 1)) # dashingL [0.05,0.05] 0)
    \end{diagram}
    \end{center}
    \caption{An inactive node whose parent is: (L) active (R) inactive} \label{fig:inactive-child}
    \end{figure}
    In this case $p = l \oplus r$ by definition, so $r$ can be
    computed as $(-l) \oplus p$. (Not $p \ominus l$, since the
    group may not be commutative!)
  \item Otherwise, the situation looks like the right side of
    \pref{fig:inactive-child}.  Again $r = (-l) \oplus p$, but we do
    not know the value of $p$.  However, since $p$ is closer to its
    nearest active ancestor than $r$, by the induction hypothesis we
    can find an expression for $p$ using only the values of active
    nodes; substituting this into $r = (-l) \oplus p$ yields the
    desired expression for $r$.
  \end{itemize}
  As for taking logarithmic time, the inductive case shows that the
  number of operations ultimately needed to compute $r$ grows linearly
  with the depth of $r$ from its nearest active ancestor, which is
  bounded by the depth of the tree.
\end{proof}

This proof is, in fact, an algorithm, although this algorithm isn't
typically used, because it is too specialized. Simply being able to
\emph{recover} all the discarded information isn't good enough; we
need to be able to perform range queries and updates as well.  Updates
are easy: as before, we only need to update nodes along the path from
the modified leaf to the root, simply skipping any inactive nodes
along the way.  However, it is less clear that we can still do range
queries in $O(\lg n)$ time.  Naively, we would need to do $O(\lg n)$
work (using the above algorithm) to reconstruct each of the $O(\lg n)$
nodes needed to compute a range sum, leading to $O(\lg^2 n)$ time.
This isn't bad, but we can do better.

\begin{theorem}
  Given a thinned segment tree, the sum of \emph{any prefix} of the
  original array can be computed, in $O(\lg n)$ time, using only the
  values of active nodes.
\end{theorem}
\begin{proof}
  By induction on the size $m$ of the required prefix.  In the base
  case, when $m=0$, the sum of an empty prefix is obviously easy to
  compute given the existence of an identity value $\mempty$.
  Otherwise, consider whether $m$ is even or odd.
  \begin{itemize}
  \item If $m=2k$ is even, then \todoi{picture!} the prefix sum of the
    first $2k$ array elements is the same as the prefix sum of the
    first $k$ elements one level up, which we can find by induction.
    \todoi{Say something more general, either here or previously,
      about the fact that removing the last level of a segment tree
      leaves us with another valid segment tree.}
  \item On the other hand, if $m = 2k+1$ is odd, then \todoi{picture!}
    the last element in the desired range is a left child (or the root
    itself, if $m = 1$) and therefore active.  We can therefore find
    the sum of the first $2k+1$ elements by combining the sum of the
    first $2k$ elements with the value of the single active element at
    the end.
  \end{itemize}
  \todoi{Explain why this takes $O(\lg n)$ time.}
  \todoi{Turn this into working code??}
\end{proof}

\begin{corollary}
  After inactivating all the right children in a segment tree, we can
  still perform any range query in $O(\lg n)$ time.
\end{corollary}
\begin{proof}
  $RQ(i,j) = P(j) \ominus P(i-1)$. \todoi{picture}
\end{proof}

Note that computing $RQ(i,i)$ gives us another way to recover the
value of an individual inactive element.

\section{Fenwick trees}

How should we actually represent a thinned segment tree?  If we stare
at \pref{fig:deactivate-right} again, an obvious strategy suggests
itself: simply take every active node and ``slide'' it down and to the
right until it lands in an empty spot in the underlying array, as
illustrated in \pref{fig:sliding-right}.  This sets up a one-to-one
correspondence between active nodes and indices in the range
$1 \dots n$.  Another way to understand this indexing scheme is to use
a postorder traverasal of the tree, skipping over inactive nodes and
giving consecutive indices to active nodes encountered during the
traversal.

\begin{figure}
\begin{center}
\begin{diagram}[width=300]
  import FenwickDiagrams
  import SegTree
  import Data.Monoid
  import Control.Arrow ((***), first, second)

  dia :: Diagram B
  dia = vsep 0.5
    [ sampleArray
      # mkSegTree
      # deactivate
      # drawSegTree opts
    , arrowV (2 *^ unit_Y)
    , sampleArray
    # mkFenwickArray
    # drawArray (draw . getSum)
    # centerX
    ]

  opts = (mkSTOpts (showInactiveOpts False))
    { drawEdge = drawSlidingEdges }
\end{diagram}
\end{center}
\caption{Sliding active values down a thinned segment tree} \label{fig:sliding-right}
\end{figure}

This method of storing the active nodes from a thinned segment tree in
an array is precisely what is commonly known as a \emph{Fenwick tree},
or \emph{bit-indexed tree}. \todoi{XXX cite} Although this is a clever use of
space, the big question is how to implement the update and range query
operations.  Our implementations of these operations for segment trees
worked by recursively descending through the tree. When storing the
active nodes of a thinned tree in an array, it is not obvious what
operations on array indices will correspond to moving around the tree.

\begin{diagram}[width=300]
  import FenwickDiagrams
  import SegTree

  dia :: Diagram B
  dia = sampleArray
    # mkSegTree
    # deactivate
    # drawSegTree stOpts

  stOpts = (mkSTOpts nOpts)
    { leanRight = True }

  nOpts = (showInactiveOpts False)
    { leanRightN = True }
\end{diagram}

By comparison, numbering a full binary tree in level order leads to
very nice and obvious math for moving around the tree:

\todoi{picture of full binary tree numbered in level order}

In particular, the root of the tree has index $1$, and the left and
right children of node $i$ are $2i$ and $2i+1$, respectively.  That
is, to get from a node to its children, shift left by one bit and then
add $1$ (for the right child) or not (for the left child).
Conversely, to get from a node to its parent, just shift right by one
bit.

\todoi{This is a
  Fenwick tree, or bit-indexed tree.  Question: how to carry out the
  operations?  Code is clever, concise, fast in practice, and
  extremely nonobvious.  Our goal: derive it!}


Our goal will be to first derive functions for converting back and
forth between Fenwick numbering and full binary tree numbering.  Then
we can derive operations on Fenwick trees by converting to binary tree
numbering, doing operation, and converting back.  XXX fusing away the
conversion.

% \begin{verbatim}
% data BT a where
%   Leaf   :: a -> BT a
%   Branch :: a -> BT a -> BT a -> BT a

% data Nat where
%   Z :: Nat
%   S :: Nat -> Nat

% data Bin where
%   One :: Bin
%   O :: Bin -> Bin
%   I :: Bin -> Bin

% bt :: Nat -> Bin -> BT Bin
% bt Z     i = Leaf i
% bt (S n) i = Branch i (bt n (O i)) (bt n (I i))
% \end{verbatim}

%% Acknowledgments
\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
  % This material is based upon work supported by the
  % \grantsponsor{GS100000001}{National Science
  %   Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
  % No.~\grantnum{GS100000001}{nnnnnnn} and Grant
  % No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
  % conclusions or recommendations expressed in this material are those
  % of the author and do not necessarily reflect the views of the
  % National Science Foundation.
\end{acks}


% Bibliography
\bibliography{fenwick}


%% Appendix
% \appendix
% \section{Appendix}

% Text of appendix \ldots

\end{document}
