% -*- compile-command: "stack exec -- rubber -d --unsafe fenwick.tex" -*-

%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[acmsmall]{acmart}\settopmatter{}


%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{ICFP} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2020}
\acmMonth{9}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format must update the '\documentclass' and
%% topmatter commands above; see 'acmart-sigplanproc-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\usepackage{booktabs}   %% For formal tables: http://ctan.org/pkg/booktabs
\usepackage{todonotes}
\usepackage{enumitem}
\newcommand{\todoi}[2][]{\todo[inline, #1]{#2}}
\usepackage[backend=pgf, input, extension=pgf, outputdir=diagrams]{diagrams-latex}

\usepackage{prettyref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Prettyref

\newrefformat{fig}{Figure~\ref{#1}}
\newrefformat{sec}{section~\ref{#1}}
\newrefformat{eq}{equation~\eqref{#1}}
\newrefformat{prob}{Problem~\ref{#1}}
\newrefformat{tab}{Table~\ref{#1}}
\newrefformat{thm}{Theorem~\ref{#1}}
\newrefformat{lem}{Lemma~\ref{#1}}
\newrefformat{claim}{Claim~\ref{#1}}
\newrefformat{obs}{Observation~\ref{#1}}
\newrefformat{prop}{Proposition~\ref{#1}}
\newrefformat{defn}{Definition~\ref{#1}}
\newrefformat{cor}{Corollary~\ref{#1}}
\providecommand{\pref}{}
\renewcommand{\pref}[1]{\prettyref{#1}}

% \Pref is just like \pref but it uppercases the first letter; for use
% at the beginning of a sentence.
\providecommand{\Pref}{}
\renewcommand{\Pref}[1]{%
  \expandafter\ifx\csname r@#1\endcsname\relax {\scriptsize[ref]}
    \else
    \edef\reftext{\prettyref{#1}}\expandafter\MakeUppercase\reftext
    \fi
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\mempty}{\ensuremath{\varepsilon}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

%% Title information
\title{Functional Pearl: You Could Have Invented Fenwick Trees}
   %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
% \titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
% \subtitle{Subtitle}                     %% \subtitle is optional
% \subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{Brent A. Yorgey}
% \authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
% \orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  % \position{Position1}
  \department{Department of Mathematics and Computer Science}
  \institution{Hendrix College}            %% \institution is required
  \streetaddress{1600 Washington Ave.}
  \city{Conway}
  \state{AR}
  \postcode{72032}
  \country{USA}                    %% \country is recommended
}
\email{yorgey@hendrix.edu}          %% \email is recommended


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
Text of abstract \ldots.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{keyword1, keyword2, keyword3}  %% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle


\section{Introduction}

XXX write about application in arithmetic coding: need to quickly find
prefix sums of probabilities.  Read up on this a bit more.

Suppose we have a sequence of $n$ integers $a_1, a_2, \dots, a_n$, and
want to be able to perform two operations:

\begin{enumerate}[label=(\Alph*)]
\item Modify the value at index $i$.
\item Find the sum of all values in a particular range $[i \dots j]$,
  that is, $a_i + a_{i+1} + \dots + a_j$.
\end{enumerate}

If we simply store the integers in a mutable array, then we can modify
the value at a given index in constant time, but finding the sum of a
range requires up to $O(n)$ time, since we must iterate through the
range $i \dots j$ to add up the values.

In order to improve the running time of the range sum operation, an
obvious idea is to somehow cache (some) range sums.  However, this
must be done with care, since the cached sums must also be updated
appropriately when modifying a value.  For example, a straightforward
approach would be to use an array $P$ where $P[i]$ stores the prefix
sum $a_1 + \dots + a_i$.  Now finding range sums is fast: we can
obtain $a_i + \dots + a_j$ in constant time by computing
$P[j] - P[i-1]$ (for convenience we store $P[0] = 0$ so this works
even when $i=1$).  Unfortunately, modifying a value now takes linear
time: changing $a_i$ requires updating every $P[j]$ for $j \geq i$.

Can we somehow have the best of both worlds?  The answer, known since
at least XXX (citation), is yes: we can get both operations to run in
$O(\lg n)$ time if we use a divide-and-conquer approach to caching
range sums.  Specifically, make a binary tree with the sequence at the
leaves, and have every internal node store the sum of its two
children.  (This should be a familiar idea to many functional
programmers; for example, finger trees
\citep{Hinze-Paterson:FingerTree} use a similar sort of scheme.)  The
resulting data structure is known as a \emph{segment tree} (XXX
citation?), presumably because each internal node ultimately caches
the sum of a (contiguous) \emph{segment} of the underlying sequence.
For simplicity, we will assume that $n$ is a power of two, although it
is easy to generalize to situations where it is not (for example, by
padding with zero to force the length to be a power of
two). \pref{fig:segment-tree} shows a segment tree built on a random
sample array of length $n=16$. Each leaf of the tree corresponds to an
array entry; each internal node is shown with a grey bar showing the
range of the underlying array of which it is the sum.

\todoi{Note that ``segment tree'' means two different things.  The
  Wikipedia article is about something used in computational geometry
  for representing intervals.  But lots of places on the web,
  specially competitive programming stuff, use it to refer to this
  simpler thing.}

\begin{figure}
\begin{center}
\begin{diagram}[width=300]
  import FenwickDiagrams
  import SegTree

  dia :: Diagram B
  dia = sampleArray
    # mkSegTree
    # fmap getSum
    # drawSegTree def
\end{diagram}
\end{center}
\caption{A segment tree} \label{fig:segment-tree}
\end{figure}

\todoi{picture of the prefix sum array for comparison?}

\begin{enumerate}
\item To update the value at index $i$, we also need to update any
  cached range sums which include it.  These are exactly the nodes
  along the path from the leaf at index $i$ to the root of the tree;
  there are $O(\log n)$ such nodes.  \pref{fig:segment-tree-update}
  illustrates this update process for the example segment tree.

\begin{figure}
\begin{center}
\begin{diagram}[width=300]
  import FenwickDiagrams
  import SegTree
  import Data.Monoid
  import Control.Arrow ((***))

  dia :: Diagram B
  dia = sampleArray
    # map ((,) (Any False))
    # mkSegTree
    # update 5 (Any True, Sum 3)
    # fmap (getAny *** getSum)
    # drawSegTree showUpdateOpts
\end{diagram}
\end{center}
\caption{Updating a segment tree} \label{fig:segment-tree-update}
\end{figure}

\item To compute the range sum $a_i + \dots + a_j$, we recurse through
  the tree while keeping track of the range covered by the current
  node.
  \begin{itemize}
  \item If the range of the current node is wholly contained within
    the desired range $i \dots j$, return the value of the current
    node.
  \item If the range of the current node is wholly disjoint from the
    desired range, return $0$.
  \item Otherwise, recurse on both children and return the sum of the
    results.
  \end{itemize}
\begin{figure}
\begin{center}
\begin{diagram}[width=300]
  import FenwickDiagrams
  import SegTree
  import Data.Monoid
  import Control.Arrow ((***), second)

  dia :: Diagram B
  dia = vsep 0.7
    [ sampleArray
      # mkSegTree
      # rq' i j
      # fst
      # fmap (second getSum)
      # drawSegTree showRangeOpts
    , (fst (leafX i n) ^& 0) ~~ (snd (leafX j n) ^& 0)
      # lc green
      # applyStyle defRangeStyle
    ]
    where
      i = 4
      j = 11
      n = length sampleArray
\end{diagram}
\end{center}
\caption{Computing a range sum from a segment tree} \label{fig:segment-tree-range-sum}
\end{figure}
  XXX analysis, we visit at most $2 \lg n$ nodes.
\end{enumerate}

\begin{figure}
\begin{center}
\begin{diagram}[width=300]
  import FenwickDiagrams
  import SegTree
  import Data.Monoid
  import Control.Arrow ((***), second)

  dia :: Diagram B
  dia = vsep 0.7
    [ sampleArray4
      # mkSegTree
      # rq' i j
      # fst
      # fmap (second getSum)
      # drawSegTree (showRangeOpts' False False)
    , (fst (leafX i n) ^& 0) ~~ (snd (leafX j n) ^& 0)
      # lc green
      # applyStyle defRangeStyle
    ]
    where
      i = 12
      j = 42
      n = length sampleArray4
\end{diagram}
\end{center}
\caption{Computing a range sum from a segment tree} \label{fig:segment-tree-update}
\end{figure}

\section{Segment Trees, Generally}

Although most reference material on segment trees (or Fenwick trees)
talks about sums of integers, this is needlessly specific.  In
general, all we need is a sequence of elements $a_1, \dots, a_n$ from
some \emph{monoid}.  Recall that a monoid is a set $M$ together with
an associative binary operation $\oplus$ and an identity element
$\varepsilon \in M$ such that
$m \oplus \mempty = \mempty \oplus m = m$ for all $m \in M$. We will
continue to talk about ``sums'' of elements of a monoid $M$ even
though the monoidal operation need not be sum-like in general (for
example, the set of natural numbers forms a monoid under
multiplication).

\todoi{Haskell implementation.}
\todoi{requires 2x storage.  Indexing scheme?  Relevant in an array implementation.}

\section{Segment Trees are Redundant}

Of course segment trees are redundant in the sense that they cache
range sums which could easily be recomputed from the original
sequence.  That's the whole point: caching these ``redundant'' sums
allows us to compute arbitrary range sums much more quickly, without
incurring a high cost to maintain them.  But segment trees are
redundant in a stronger sense: it turns out that we can throw out
almost \emph{half} of the data in a segment tree and still retain
$O(\log n)$ performance for both operations!

How, you ask?  Simple: just throw out the data associated with
\emph{every right child}.

\todoi{picture of segment tree with right children deactivated.  Call
  left children \emph{active} and right children \emph{inactive}.}

First, let's prove that there is enough information remaining to
reconstruct the information that was discarded.

\begin{theorem}
  After deactivating all the right children in a segment tree, the
  value of any inactive node can be computed using only the values of
  active nodes.
\end{theorem}
\begin{proof}
  The proof is by induction on the depth of an inactive node from its
  lowest active ancestor.
  \begin{itemize}
  \item In the base case, if an inactive node is at depth $1$ from its
    lowest active ancestor, the situation looks like this:
    \todoi{picture}.  In this case $p = lr$ by definition, so $r =
    l^{-1}p$.
  \item Otherwise, the situation looks like this: \todoi{picture}.
    Again $r = l^{-1}p$, but we do not know the value of $p$.
    However, since $p$ is closer to its lowest active ancestor than
    $r$, by the induction hypothesis we can find an expression for $p$
    using only the values of active nodes; substituting this into $r =
    l^{-1}p$ yields the desired expression for $r$.
  \end{itemize}
\end{proof}

This proof is, in fact, an algorithm, although it isn't typically
used: \todoi{initial segments, subtract}

\todoi{Send every active node down to the right until it lands in an
  empty spot.  It is clear that this sets up a 1-1 correspondence
  between active nodes and indices $1 \dots n$; corresponds to
  numbering active nodes using a preorder traversal.  This is a
  Fenwick tree, or bit-indexed tree.  Question: how to carry out the
  operations?  Code is clever, concise, fast in practice, and
  extremely nonobvious.  Our goal: derive it!}

\section{Indices}

We now have a tree structure with nodes numbered like so: in short, we
start with a full binary tree, ``deactivate'' any right children, and
then number the remaining nodes using a preorder traversal (that is,
each node's left and right children are recursively numbered first,
then the node itself).  However, it is not obvious what mathematical
operations on indices are needed to move about the tree.

\todoi{picture}

By comparison, numbering a full binary tree in level order leads to
very nice and obvious math for moving around the tree:

\todoi{picture of full binary tree numbered in level order}

In particular, the root of the tree has index $1$, and the left and
right children of node $i$ are $2i$ and $2i+1$, respectively.  That
is, to get from a node to its children, shift left by one bit and then
add $1$ (for the right child) or not (for the left child).
Conversely, to get from a node to its parent, just shift right by one
bit.

Our goal will be to first derive functions for converting back and
forth between Fenwick numbering and full binary tree numbering.  Then
we can derive operations on Fenwick tree by converting to binary tree
numbering, doing operation, and converting back.

\begin{verbatim}
data BT a where
  Leaf   :: a -> BT a
  Branch :: a -> BT a -> BT a -> BT a

data Nat where
  Z :: Nat
  S :: Nat -> Nat

data Bin where
  One :: Bin
  O :: Bin -> Bin
  I :: Bin -> Bin

bt :: Nat -> Bin -> BT Bin
bt Z     i = Leaf i
bt (S n) i = Branch i (bt n (O i)) (bt n (I i))
\end{verbatim}

%% Acknowledgments
\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
  % This material is based upon work supported by the
  % \grantsponsor{GS100000001}{National Science
  %   Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
  % No.~\grantnum{GS100000001}{nnnnnnn} and Grant
  % No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
  % conclusions or recommendations expressed in this material are those
  % of the author and do not necessarily reflect the views of the
  % National Science Foundation.
\end{acks}


% Bibliography
\bibliography{fenwick}


%% Appendix
% \appendix
% \section{Appendix}

% Text of appendix \ldots

\end{document}
