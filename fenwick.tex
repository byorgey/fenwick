% -*- compile-command: "stack exec -- pdflatex --enable-write18 fenwick.tex" -*-

%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[acmsmall]{acmart}\settopmatter{}


%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{ICFP} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2020}
\acmMonth{9}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
% \bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format must update the '\documentclass' and
%% topmatter commands above; see 'acmart-sigplanproc-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables: http://ctan.org/pkg/booktabs
\usepackage{todonotes}
\newcommand{\todoi}[2][]{\todo[inline, #1]{#2}}
\usepackage[backend=pgf, input, extension=pgf, outputdir=diagrams]{diagrams-latex}

\begin{document}

%% Title information
\title[Short Title]{Fenwick Trees}         %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
% \titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
% \subtitle{Subtitle}                     %% \subtitle is optional
% \subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{Brent A. Yorgey}
% \authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
% \orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  % \position{Position1}
  \department{Department of Mathematics and Computer Science}
  \institution{Hendrix College}            %% \institution is required
  \streetaddress{1600 Washington Ave.}
  \city{Conway}
  \state{AR}
  \postcode{72032}
  \country{USA}                    %% \country is recommended
}
\email{yorgey@hendrix.edu}          %% \email is recommended


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
Text of abstract \ldots.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{keyword1, keyword2, keyword3}  %% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle


\section{Introduction}

Suppose we have a sequence of $n$ integers $a_1, a_2, \dots, a_n$. XXX
two operations:

\begin{enumerate}
\item Modify the value at index $i$.
\item Find the sum of all values in a particular range $[i \dots j]$,
  that is, $a_i + a_{i+1} + \dots + a_j$.
\end{enumerate}

If we simply store the integers in an array, then operation (1) takes
constant time, but operation (2) requires up to $O(n)$ time, since we
must iterate through the range $i \dots j$ to add up the values.

In order to improve the running time of operation (2), an obvious idea
is to somehow cache (some) range sums.  However, this must be done
with care, since the cached sums must also be updated appropriately
when performing operation (1).  For example, a straightforward
approach would be to use an array $P$ where $P[i]$ stores the prefix
sum $a_1 + \dots + a_i$.  Now operation (2) is fast: we can obtain the
range sum $a_i + \dots + a_j$ in constant time by computing
$P[j] - P[i-1]$ (for convenience we store $P[0] = 0$ so this works
even when $i=1$).  Unfortunately, however, operation (1) now takes
$O(n)$ time: to change $a_i$ requires updating every $P[j]$ for $j
\geq i$.

Can we somehow have the best of both worlds?  The answer, known since
at least XXX (citation), is yes: we can get both operations to run in
$O(\log n)$ time if we use a divide-and-conquer approach to caching
range sums.  XXX familiar technique (cite finger trees).  Make a
binary tree with the sequence at the leaves; every internal node
stores the sum of its two child nodes.  The resulting data structure
is known as a \emph{segment tree} (citation?), presumably because each
internal node ultimately caches the sum of a (contiguous)
\emph{segment} of the underlying sequence.

\todoi{assume $n$ is a power of two for simplicity (could pad with zeros)}

\begin{diagram}[width=300]
  import FenwickDiagrams
  import SegTree

  dia :: Diagram B
  dia = sampleArray # mkSegTree # fmap (\(Sum n) -> text (show n) <> square 1) # drawSegTree
\end{diagram}

\todoi{picture of a segment tree}
\todoi{picture of the prefix sum array for comparison?}

\begin{enumerate}
\item To update the value at index $i$, we also need to update any
  cached range sums which include it.  These are exactly the nodes
  along the path from the leaf at index $i$ to the root of the tree;
  there are $O(\log n)$ such nodes.
\item To compute the range sum $a_i + \dots + a_j$, we recurse through
  the tree while keeping track of the range covered by the current
  node.
  \begin{itemize}
  \item If the range of the current node is wholly contained within
    the desired range $i \dots j$, return the value of the current
    node.
  \item If the range of the current node is wholly disjoint from the
    desired range, return $0$.
  \item Otherwise, recurse on both children and return the sum of the
    results.
  \end{itemize}
  XXX analysis, we visit at most $2 \lg n$ nodes.
\end{enumerate}

\section{Segment Trees, Generally}

Although most reference material on segment trees (or Fenwick trees)
talks about \emph{sums}, this is needlessly specific.  In general, all
we need is a sequence of elements $a_1, \dots, a_n$ from some
\emph{monoid} $M$.  \todoi{Recall what a monoid is, notation.  Will
  still talk about ``sums''.}

\todoi{Haskell implementation.}
\todoi{requires 2x storage.  Indexing scheme?  Relevant in an array implementation.}

\section{Segment Trees are Redundant}

Of course segment trees are redundant in the sense that they cache
range sums which could easily be recomputed from the original
sequence.  But that's the whole point: caching these ``redundant''
sums allows us to compute arbitrary range sums much more quickly,
without incurring a high cost to maintain them.

But segment trees are redundant in a stronger sense: it turns out that
we can throw out almost \emph{half} of the data in a segment tree and
still retain the $O(\log n)$ performance for both operations!  How,
you ask?  Simple: just throw out the data associated with \emph{every
  right child}.

\todoi{picture of segment tree with right children deactivated.  Call
  left children \emph{active} and right children \emph{inactive}.}

First, let's prove that there is enough information remaining to
reconstruct the information that was discarded.

\begin{theorem}
  After deactivating all the right children in a segment tree, the
  value of any inactive node can be computed using only the values of
  active nodes.
\end{theorem}
\begin{proof}
  The proof is by induction on the depth of an inactive node from its
  lowest active ancestor.
  \begin{itemize}
  \item In the base case, if an inactive node is at depth $1$ from its
    lowest active ancestor, the situation looks like this:
    \todoi{picture}.  In this case $p = lr$ by definition, so $r =
    l^{-1}p$.
  \item Otherwise, the situation looks like this: \todoi{picture}.
    Again $r = l^{-1}p$, but we do not know the value of $p$.
    However, since $p$ is closer to its lowest active ancestor than
    $r$, by the induction hypothesis we can find an expression for $p$
    using only the values of active nodes; substituting this into $r =
    l^{-1}p$ yields the desired expression for $r$.
  \end{itemize}
\end{proof}

This proof is, in fact, an algorithm, although it isn't typically
used: \todoi{initial segments, subtract}

\todoi{Send every active node down to the right until it lands in an
  empty spot.  It is clear that this sets up a 1-1 correspondence
  between active nodes and indices $1 \dots n$; corresponds to
  numbering active nodes using a preorder traversal.  This is a
  Fenwick tree, or bit-indexed tree.  Question: how to carry out the
  operations?  Code is clever, concise, fast in practice, and
  extremely nonobvious.  Our goal: derive it!}

\section{Indices}

We now have a tree structure with nodes numbered like so: in short, we
start with a full binary tree, ``deactivate'' any right children, and
then number the remaining nodes using a preorder traversal (that is,
each node's left and right children are recursively numbered first,
then the node itself).  However, it is not obvious what mathematical
operations on indices are needed to move about the tree.

\todoi{picture}

By comparison, numbering a full binary tree in level order leads to
very nice and obvious math for moving around the tree:

\todoi{picture of full binary tree numbered in level order}

In particular, the root of the tree has index $1$, and the left and
right children of node $i$ are $2i$ and $2i+1$, respectively.  That
is, to get from a node to its children, shift left by one bit and then
add $1$ (for the right child) or not (for the left child).
Conversely, to get from a node to its parent, just shift right by one
bit.

Our goal will be to first derive functions for converting back and
forth between Fenwick numbering and full binary tree numbering.  Then
we can derive operations on Fenwick tree by converting to binary tree
numbering, doing operation, and converting back.

\begin{verbatim}
data BT a where
  Leaf   :: a -> BT a
  Branch :: a -> BT a -> BT a -> BT a

data Nat where
  Z :: Nat
  S :: Nat -> Nat

data Bin where
  One :: Bin
  O :: Bin -> Bin
  I :: Bin -> Bin

bt :: Nat -> Bin -> BT Bin
bt Z     i = Leaf i
bt (S n) i = Branch i (bt n (O i)) (bt n (I i))
\end{verbatim}

%% Acknowledgments
\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
  This material is based upon work supported by the
  \grantsponsor{GS100000001}{National Science
    Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
  No.~\grantnum{GS100000001}{nnnnnnn} and Grant
  No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
  conclusions or recommendations expressed in this material are those
  of the author and do not necessarily reflect the views of the
  National Science Foundation.
\end{acks}


%% Bibliography
% \bibliography{fenwick}


%% Appendix
% \appendix
% \section{Appendix}

% Text of appendix \ldots

\end{document}
